# -*- coding: utf-8 -*-
"""individual_task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GDqA0w9TIiZHO-MM0LZNqhzsI9PlJnei
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.svm import SVR

"""# Вхідні дані"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

# Завантаження даних
df = pd.read_csv('/content/drive/MyDrive/real_estate.csv')

# Перевірка пропущених значень
print(df.isnull().sum())

# Видалення рядків з пропущеними значеннями (тільки рядки, які будуть використані в подальшій обробці)
df_clean = df.dropna(subset=['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'Y house price of unit area'])
print(df_clean.isnull().sum())  # Повторна перевірка пропущених значень

"""# Створення моделі"""

# Вибір ознак та цільової змінної
X = df_clean[['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores']]
y = df_clean['Y house price of unit area']

# Розділення даних на тренувальну та тестову вибірки
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Стандартизація даних
scaler = StandardScaler()

# Вибір центрів з використанням K-means для ініціалізації RBF нейронів
kmeans = KMeans(n_clusters=3)  # 3 центри
kmeans.fit(X_train)
centers = kmeans.cluster_centers_

# Модель класифікації на базі SVM з RBF ядром
model = make_pipeline(scaler, SVR(kernel='rbf'))
model.fit(X_train, y_train)

"""# Створення нового обʼєкту"""

# Введення ознак нового обʼєкту
x2 = float(input("Введіть бажаний вік нерухомості (р): "))

x3 = float(input("Введіть бажану відстань до найближчої станції метро (м): "))

x4 = int(input("Введіть бажану кількість продуктових магазинів в пішій доступності: "))

# Створення нового обʼєкту з введеними ознаками
new_object = np.array([[x2, x3, x4]])

"""# Робота моделі"""

# Прогнозування цільової змінної обʼєкту
new_object_prediction = ((model.predict(new_object) * 10000)/3.3)*0.031
print(f"Приблизна вартість нерухомості ($/м²): {new_object_prediction}")

# Оцінка точності моделі
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Вивід результатів
print(f"Середньоквадратична помилка (MSE): {mse:.2f}")
print(f"Середньоабсолютна помилка (MAE): {mae:.2f}")
print(f"Коефіцієнт детермінації (R²): {r2:.2f}")

"""# Візуалізація"""

# Дані
x_coord = X_train['X3 distance to the nearest MRT station']
y_coord = ((y_train * 10000)/3.3)*0.031
sizes = X_train['X2 house age'] * 4
colors = X_train['X4 number of convenience stores']

# Дані нового обʼєкту
new_x = new_object[0, 1]
new_y = new_object_prediction

# Графік
plt.scatter(x_coord, y_coord, s=sizes, c=colors, cmap='viridis', alpha=0.7, edgecolors='w')
plt.colorbar(label='кількість продуктових магазинів в пішій доступності')
plt.xlabel('відстань до найближчої станції метро (м)')
plt.ylabel('вартість нерухомості ($/м²)')
plt.title('Графік нерухомості')
plt.scatter(new_x, new_y, s=250, c='red', alpha=1, edgecolors='w', marker='*', label='Новий обʼєкт')
plt.legend()